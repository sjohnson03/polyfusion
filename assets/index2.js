import{V as T,B as K,a as N,M as q,b as E,c as V}from"./index.js";class B{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y,this.array[this.top++]=t.z}}class Q{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y}}class v{constructor(t){this.plane=null,this.front=null,this.back=null,this.polygons=[],t&&this.build(t)}clone(){const t=new v;return t.plane=this.plane&&this.plane.clone(),t.front=this.front&&this.front.clone(),t.back=this.back&&this.back.clone(),t.polygons=this.polygons.map(s=>s.clone()),t}invert(){for(let s=0;s<this.polygons.length;s++)this.polygons[s].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();const t=this.front;this.front=this.back,this.back=t}clipPolygons(t){if(!this.plane)return t.slice();let s=new Array,o=new Array;for(let n=0;n<t.length;n++)this.plane.splitPolygon(t[n],s,o,s,o);return this.front&&(s=this.front.clipPolygons(s)),this.back?o=this.back.clipPolygons(o):o=[],s.concat(o)}clipTo(t){this.polygons=t.clipPolygons(this.polygons),this.front&&this.front.clipTo(t),this.back&&this.back.clipTo(t)}allPolygons(){let t=this.polygons.slice();return this.front&&(t=t.concat(this.front.allPolygons())),this.back&&(t=t.concat(this.back.allPolygons())),t}build(t){if(!t.length)return;this.plane||(this.plane=t[0].plane.clone());const s=[],o=[];for(let n=0;n<t.length;n++)this.plane.splitPolygon(t[n],this.polygons,this.polygons,s,o);s.length&&(this.front||(this.front=new v),this.front.build(s)),o.length&&(this.back||(this.back=new v),this.back.build(o))}}class m{constructor(t=0,s=0,o=0){this.x=t,this.y=s,this.z=o}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}clone(){return new m(this.x,this.y,this.z)}negate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}times(t){return this.x*=t,this.y*=t,this.z*=t,this}dividedBy(t){return this.x/=t,this.y/=t,this.z/=t,this}lerp(t,s){return this.add(new m().copy(t).sub(this).times(s))}unit(){return this.dividedBy(this.length())}length(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2)+Math.pow(this.z,2))}normalize(){return this.unit()}cross(t){const s=this.clone(),o=s.x,n=s.y,r=s.z,l=t.x,g=t.y,u=t.z;return this.x=n*u-r*g,this.y=r*l-o*u,this.z=o*g-n*l,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}toVector3(){return new T(this.x,this.y,this.z)}}class x{constructor(t,s){this.normal=t,this.w=s,this.normal=t,this.w=s}clone(){return new x(this.normal.clone(),this.w)}flip(){this.normal.negate(),this.w=-this.w}splitPolygon(t,s,o,n,r){let f=0;const h=[];for(let w=0;w<t.vertices.length;w++){const i=this.normal.dot(t.vertices[w].pos)-this.w,e=i<-x.EPSILON?2:i>x.EPSILON?1:0;f|=e,h.push(e)}switch(f){case 0:(this.normal.dot(t.plane.normal)>0?s:o).push(t);break;case 1:n.push(t);break;case 2:r.push(t);break;case 3:{const w=[],i=[];for(let e=0;e<t.vertices.length;e++){const a=(e+1)%t.vertices.length,y=h[e],d=h[a],b=t.vertices[e],z=t.vertices[a];if(y!=2&&w.push(b),y!=1&&i.push(y!=2?b.clone():b),(y|d)==3){const k=(this.w-this.normal.dot(b.pos))/this.normal.dot(new m().copy(z.pos).sub(b.pos)),M=b.interpolate(z,k);w.push(M),i.push(M.clone())}}w.length>=3&&n.push(new P(w,t.shared)),i.length>=3&&r.push(new P(i,t.shared));break}}}static fromPoints(t,s,o){const n=new m().copy(s).sub(t).cross(new m().copy(o).sub(t)).normalize();return new x(n.clone(),n.dot(t))}}x.EPSILON=1e-5;class P{constructor(t,s){this.vertices=t,this.shared=s,this.plane=x.fromPoints(t[0].pos,t[1].pos,t[2].pos)}clone(){return new P(this.vertices.map(t=>t.clone()),this.shared)}flip(){this.vertices.reverse().map(t=>t.flip()),this.plane.flip()}}class A{constructor(t,s,o,n){this.pos=new m().copy(t),this.normal=new m().copy(s),this.uv=new m().copy(o),this.uv.z=0,n&&(this.color=new m().copy(n))}clone(){return new A(this.pos,this.normal,this.uv,this.color)}flip(){this.normal.negate()}interpolate(t,s){return new A(this.pos.clone().lerp(t.pos,s),this.normal.clone().lerp(t.normal,s),this.uv.clone().lerp(t.uv,s),this.color&&t.color&&this.color.clone().lerp(t.color,s))}}class p{constructor(){this.polygons=[]}static fromPolygons(t){const s=new p;return s.polygons=t,s}static fromGeometry(t,s){let o=[];const n=t.attributes.position,r=t.attributes.normal,l=t.attributes.uv,g=t.attributes.color,u=t.groups;let c;if(t.index)c=t.index.array;else{c=new Uint16Array(n.array.length/n.itemSize|0);for(let h=0;h<c.length;h++)c[h]=h}const f=c.length/3|0;o=new Array(f);for(let h=0,w=0,i=c.length;h<i;h+=3,w++){const e=new Array(3);for(let a=0;a<3;a++){const y=c[h+a],d=y*3,b=y*2,z=n.array[d],k=n.array[d+1],M=n.array[d+2],F=r.array[d],I=r.array[d+1],R=r.array[d+2],L=l==null?void 0:l.array[b],j=l==null?void 0:l.array[b+1];e[a]=new A(new m(z,k,M),new m(F,I,R),new m(L,j,0),g&&new m(g.array[d],g.array[d+1],g.array[d+2]))}if(s===void 0&&u&&u.length>0)for(const a of u)h>=a.start&&h<a.start+a.count&&(o[w]=new P(e,a.materialIndex));else o[w]=new P(e,s)}return p.fromPolygons(o.filter(h=>!Number.isNaN(h.plane.normal.x)))}static toGeometry(t,s){let o=0;const n=t.polygons;for(const i of n)o+=i.vertices.length-2;const r=new K,l=new B(o*3*3),g=new B(o*3*3),u=new Q(o*2*3);let c;const f=[],h=[];for(const i of n){const e=i.vertices,a=e.length;i.shared!==void 0&&(f[i.shared]||(f[i.shared]=[])),a&&e[0].color!==void 0&&(c||(c=new B(o*3*3)));for(let y=3;y<=a;y++)(i.shared===void 0?h:f[i.shared]).push(l.top/3,l.top/3+1,l.top/3+2),l.write(e[0].pos),l.write(e[y-2].pos),l.write(e[y-1].pos),g.write(e[0].normal),g.write(e[y-2].normal),g.write(e[y-1].normal),u&&(u.write(e[0].uv),u.write(e[y-2].uv),u.write(e[y-1].uv)),c&&(c.write(e[0].color),c.write(e[y-2].color),c.write(e[y-1].color))}r.setAttribute("position",new N(l.array,3)),r.setAttribute("normal",new N(g.array,3)),u&&r.setAttribute("uv",new N(u.array,2)),c&&r.setAttribute("color",new N(c.array,3));for(let i=0;i<f.length;i++)f[i]===void 0&&(f[i]=[]);if(f.length){let i=[],e=0;for(let a=0;a<f.length;a++)r.addGroup(e,f[a].length,a),e+=f[a].length,i=i.concat(f[a]);r.addGroup(e,h.length,f.length),i=i.concat(h),r.setIndex(i)}const w=new q().copy(s).invert();return r.applyMatrix4(w),r.computeBoundingSphere(),r.computeBoundingBox(),r}static fromMesh(t,s){const o=p.fromGeometry(t.geometry,s),n=new T,r=new E;r.getNormalMatrix(t.matrix);for(let l=0;l<o.polygons.length;l++){const g=o.polygons[l];for(let u=0;u<g.vertices.length;u++){const c=g.vertices[u];c.pos.copy(n.copy(c.pos.toVector3()).applyMatrix4(t.matrix)),c.normal.copy(n.copy(c.normal.toVector3()).applyMatrix3(r))}}return o}static toMesh(t,s,o){const n=p.toGeometry(t,s),r=new V(n,o);return r.matrix.copy(s),r.matrix.decompose(r.position,r.quaternion,r.scale),r.rotation.setFromQuaternion(r.quaternion),r.updateMatrixWorld(),r.castShadow=r.receiveShadow=!0,r}static union(t,s){const o=p.fromMesh(t),n=p.fromMesh(s);return p.toMesh(o.union(n),t.matrix,t.material)}static subtract(t,s){const o=p.fromMesh(t),n=p.fromMesh(s);return p.toMesh(o.subtract(n),t.matrix,t.material)}static intersect(t,s){const o=p.fromMesh(t),n=p.fromMesh(s);return p.toMesh(o.intersect(n),t.matrix,t.material)}clone(){const t=new p;return t.polygons=this.polygons.map(s=>s.clone()).filter(s=>Number.isFinite(s.plane.w)),t}toPolygons(){return this.polygons}union(t){const s=new v(this.clone().polygons),o=new v(t.clone().polygons);return s.clipTo(o),o.clipTo(s),o.invert(),o.clipTo(s),o.invert(),s.build(o.allPolygons()),p.fromPolygons(s.allPolygons())}subtract(t){const s=new v(this.clone().polygons),o=new v(t.clone().polygons);return s.invert(),s.clipTo(o),o.clipTo(s),o.invert(),o.clipTo(s),o.invert(),s.build(o.allPolygons()),s.invert(),p.fromPolygons(s.allPolygons())}intersect(t){const s=new v(this.clone().polygons),o=new v(t.clone().polygons);return s.invert(),o.clipTo(s),o.invert(),s.clipTo(o),o.clipTo(s),s.build(o.allPolygons()),s.invert(),p.fromPolygons(s.allPolygons())}inverse(){const t=this.clone();for(const s of t.polygons)s.flip();return t}toMesh(t,s){return p.toMesh(this,t,s)}toGeometry(t){return p.toGeometry(this,t)}}export{p as CSG};
